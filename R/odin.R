## Automatically generated by odin 1.1.0 - do not edit
explicit_SEIR_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "explicit_SEIR_rhs_dde"),
    dll = "squire",
    user = c("D_0", "E1_0", "E2_0", "ICU_beds", "ICase1_0", "ICase2_0",
             "IMVGetDie1_0", "IMVGetDie2_0", "IMVGetLive1_0",
             "IMVGetLive2_0", "IMVNotGetDie1_0", "IMVNotGetDie2_0",
             "IMVNotGetLive1_0", "IMVNotGetLive2_0", "IMild_0",
             "IOxGetDie1_0", "IOxGetDie2_0", "IOxGetLive1_0",
             "IOxGetLive2_0", "IOxNotGetDie1_0", "IOxNotGetDie2_0",
             "IOxNotGetLive1_0", "IOxNotGetLive2_0", "IRec1_0", "IRec2_0",
             "N_age", "R_0", "S_0", "beta_set", "dt", "gamma_E",
             "gamma_ICase", "gamma_IMild", "gamma_get_mv_die",
             "gamma_get_mv_survive", "gamma_get_ox_die",
             "gamma_get_ox_survive", "gamma_not_get_mv_die",
             "gamma_not_get_mv_survive", "gamma_not_get_ox_die",
             "gamma_not_get_ox_survive", "gamma_rec", "hosp_beds",
             "mix_mat_set", "prob_hosp",
             "prob_non_severe_death_no_treatment",
             "prob_non_severe_death_treatment", "prob_severe",
             "prob_severe_death_no_treatment", "prob_severe_death_treatment",
             "tt_ICU_beds", "tt_beta", "tt_dur_get_mv_die",
             "tt_dur_get_mv_survive", "tt_dur_get_ox_die",
             "tt_dur_get_ox_survive", "tt_hosp_beds", "tt_matrix"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("explicit_SEIR_rhs_dde", package = "squire")
      }
    },

    ## This only does something in delay models
    set_initial = function(step, y, use_dde) {
      .Call("explicit_SEIR_set_initial", private$ptr, step, y, use_dde,
            PACKAGE= "squire")
    },

    update_metadata = function() {
      meta <- .Call("explicit_SEIR_metadata", private$ptr,
                    PACKAGE = "squire")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, TRUE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("explicit_SEIR_create", user, PACKAGE = "squire")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/explicit_SEIR.json", mustWork = TRUE,
                             package = "squire")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("explicit_SEIR_set_user", private$ptr, user, PACKAGE = "squire")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(step) {
      .Call("explicit_SEIR_initial_conditions", private$ptr, step, PACKAGE = "squire")
    },

    rhs = function(step, y) {
      .Call("explicit_SEIR_rhs_r", private$ptr, step, y, PACKAGE = "squire")
    },

    update = function(step, y) {
      self$rhs(step, y)
    },

    contents = function() {
      .Call("explicit_SEIR_contents", private$ptr, PACKAGE = "squire")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(step, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_discrete(
        self, private, step, y, ..., use_names = use_names)
    }
  ))


explicit_SEIR <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  explicit_SEIR_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(explicit_SEIR) <- "odin_generator"
attr(explicit_SEIR, "generator") <- explicit_SEIR_
explicit_SEIR_deterministic_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "explicit_SEIR_deterministic_rhs_dde",
      rhs_desolve = "explicit_SEIR_deterministic_rhs_desolve",
      initmod_desolve = "explicit_SEIR_deterministic_initmod_desolve",
      output_dde = "explicit_SEIR_deterministic_output_dde"),
    dll = "squire",
    user = c("D_0", "E1_0", "E2_0", "ICU_beds", "ICase1_0", "ICase2_0",
             "IMVGetDie1_0", "IMVGetDie2_0", "IMVGetLive1_0",
             "IMVGetLive2_0", "IMVNotGetDie1_0", "IMVNotGetDie2_0",
             "IMVNotGetLive1_0", "IMVNotGetLive2_0", "IMild_0",
             "IOxGetDie1_0", "IOxGetDie2_0", "IOxGetLive1_0",
             "IOxGetLive2_0", "IOxNotGetDie1_0", "IOxNotGetDie2_0",
             "IOxNotGetLive1_0", "IOxNotGetLive2_0", "IRec1_0", "IRec2_0",
             "N_age", "R_0", "S_0", "beta_set", "gamma_E", "gamma_ICase",
             "gamma_IMild", "gamma_get_mv_die", "gamma_get_mv_survive",
             "gamma_get_ox_die", "gamma_get_ox_survive",
             "gamma_not_get_mv_die", "gamma_not_get_mv_survive",
             "gamma_not_get_ox_die", "gamma_not_get_ox_survive", "gamma_rec",
             "hosp_beds", "mix_mat_set", "p_dist", "prob_hosp",
             "prob_non_severe_death_no_treatment",
             "prob_non_severe_death_treatment", "prob_severe",
             "prob_severe_death_no_treatment", "prob_severe_death_treatment",
             "tt_ICU_beds", "tt_beta", "tt_dur_get_mv_die",
             "tt_dur_get_mv_survive", "tt_dur_get_ox_die",
             "tt_dur_get_ox_survive", "tt_hosp_beds", "tt_matrix"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("explicit_SEIR_deterministic_rhs_dde", package = "squire")
        .C("explicit_SEIR_deterministic_rhs_desolve", package = "squire")
        .C("explicit_SEIR_deterministic_initmod_desolve", package = "squire")
        .C("explicit_SEIR_deterministic_output_dde", package = "squire")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("explicit_SEIR_deterministic_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "squire")
    },

    update_metadata = function() {
      meta <- .Call("explicit_SEIR_deterministic_metadata", private$ptr,
                    PACKAGE = "squire")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("explicit_SEIR_deterministic_create", user, PACKAGE = "squire")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/explicit_SEIR_deterministic.json", mustWork = TRUE,
                             package = "squire")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("explicit_SEIR_deterministic_set_user", private$ptr, user, PACKAGE = "squire")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("explicit_SEIR_deterministic_initial_conditions", private$ptr, t, PACKAGE = "squire")
    },

    rhs = function(t, y) {
      .Call("explicit_SEIR_deterministic_rhs_r", private$ptr, t, y, PACKAGE = "squire")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("explicit_SEIR_deterministic_contents", private$ptr, PACKAGE = "squire")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_ode(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


explicit_SEIR_deterministic <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  explicit_SEIR_deterministic_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(explicit_SEIR_deterministic) <- "odin_generator"
attr(explicit_SEIR_deterministic, "generator") <- explicit_SEIR_deterministic_
less_basic_model_for_js_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "less_basic_model_for_js_rhs_dde",
      rhs_desolve = "less_basic_model_for_js_rhs_desolve",
      initmod_desolve = "less_basic_model_for_js_initmod_desolve"),
    dll = "squire",
    user = c("D0", "E0", "I_ICU0", "I_hosp0", "I_mild0", "R0", "S0",
             "beta_1", "beta_2", "gamma", "m", "mu", "p_ICU", "p_hosp",
             "p_mild", "sigma"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("less_basic_model_for_js_rhs_dde", package = "squire")
        .C("less_basic_model_for_js_rhs_desolve", package = "squire")
        .C("less_basic_model_for_js_initmod_desolve", package = "squire")
      }
    },

    ## This only does something in delay models
    set_initial = function(t, y, use_dde) {
      .Call("less_basic_model_for_js_set_initial", private$ptr, t, y, use_dde,
            PACKAGE= "squire")
    },

    update_metadata = function() {
      meta <- .Call("less_basic_model_for_js_metadata", private$ptr,
                    PACKAGE = "squire")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, FALSE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("less_basic_model_for_js_create", user, PACKAGE = "squire")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/less_basic_model_for_js.json", mustWork = TRUE,
                             package = "squire")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("less_basic_model_for_js_set_user", private$ptr, user, PACKAGE = "squire")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(t) {
      .Call("less_basic_model_for_js_initial_conditions", private$ptr, t, PACKAGE = "squire")
    },

    rhs = function(t, y) {
      .Call("less_basic_model_for_js_rhs_r", private$ptr, t, y, PACKAGE = "squire")
    },

    deriv = function(t, y) {
      self$rhs(t, y)
    },

    contents = function() {
      .Call("less_basic_model_for_js_contents", private$ptr, PACKAGE = "squire")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(t, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_ode(
        self, private, t, y, ..., use_names = use_names)
    }
  ))


less_basic_model_for_js <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  less_basic_model_for_js_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(less_basic_model_for_js) <- "odin_generator"
attr(less_basic_model_for_js, "generator") <- less_basic_model_for_js_
simple_SEIR_ <- R6::R6Class(
  "odin_model",
  cloneable = FALSE,

  private = list(
    ptr = NULL,
    use_dde = NULL,

    odin = NULL,
    variable_order = NULL,
    output_order = NULL,
    n_out = NULL,
    ynames = NULL,
    interpolate_t = NULL,
    cfuns = list(
      rhs_dde = "simple_SEIR_rhs_dde"),
    dll = "squire",
    user = c("E0", "E02", "I0", "N_age", "R0", "S0", "beta_set", "dt",
             "gamma_E", "gamma_I", "mix_mat_set", "tt_beta", "tt_matrix"),

    ## This is never called, but is used to ensure that R finds our
    ## symbols that we will use from the package; without this they
    ## cannot be found by dynamic lookup now that we use the package
    ## FFI registration system.
    registration = function() {
      if (FALSE) {
        .C("simple_SEIR_rhs_dde", package = "squire")
      }
    },

    ## This only does something in delay models
    set_initial = function(step, y, use_dde) {
      .Call("simple_SEIR_set_initial", private$ptr, step, y, use_dde,
            PACKAGE= "squire")
    },

    update_metadata = function() {
      meta <- .Call("simple_SEIR_metadata", private$ptr,
                    PACKAGE = "squire")
      private$variable_order <- meta$variable_order
      private$output_order <- meta$output_order
      private$n_out <- meta$n_out
      private$ynames <- private$odin$make_names(
        private$variable_order, private$output_order, TRUE)
      private$interpolate_t <- meta$interpolate_t
    }
  ),

  public = list(
    initialize = function(..., user = list(...), use_dde = FALSE,
                          unused_user_action = NULL) {
      private$odin <- asNamespace("odin")
      private$ptr <- .Call("simple_SEIR_create", user, PACKAGE = "squire")
      self$set_user(user = user, unused_user_action = unused_user_action)
      private$use_dde <- use_dde
      private$update_metadata()
    },

    ir = function() {
      path_ir <- system.file("odin/simple_SEIR.json", mustWork = TRUE,
                             package = "squire")
      json <- readLines(path_ir)
      class(json) <- "json"
      json
    },

    ## Do we need to have the user-settable args here? It would be
    ## nice, but that's not super straightforward to do.
    set_user = function(..., user = list(...), unused_user_action = NULL) {
      private$odin$support_check_user(user, private$user, unused_user_action)
      .Call("simple_SEIR_set_user", private$ptr, user, PACKAGE = "squire")
      private$update_metadata()
    },

    ## This might be time sensitive and, so we can avoid computing
    ## it. I wonder if that's an optimisation we should drop for now
    ## as it does not seem generally useful. This would bring us
    ## closer to the js version which requires that we always pass the
    ## time in.
    initial = function(step) {
      .Call("simple_SEIR_initial_conditions", private$ptr, step, PACKAGE = "squire")
    },

    rhs = function(step, y) {
      .Call("simple_SEIR_rhs_r", private$ptr, step, y, PACKAGE = "squire")
    },

    update = function(step, y) {
      self$rhs(step, y)
    },

    contents = function() {
      .Call("simple_SEIR_contents", private$ptr, PACKAGE = "squire")
    },

    transform_variables = function(y) {
      private$odin$support_transform_variables(y, private)
    },

    run = function(step, y = NULL, ..., use_names = TRUE) {
      private$odin$wrapper_run_discrete(
        self, private, step, y, ..., use_names = use_names)
    }
  ))


simple_SEIR <- function(..., user = list(...), use_dde = FALSE,
                     unused_user_action = NULL) {
  simple_SEIR_$new(user = user, use_dde = use_dde,
                unused_user_action = unused_user_action)
}
class(simple_SEIR) <- "odin_generator"
attr(simple_SEIR, "generator") <- simple_SEIR_
